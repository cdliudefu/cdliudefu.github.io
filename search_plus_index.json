{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:11:48 "},"content/terms.html":{"url":"content/terms.html","title":"术语","keywords":"","body":"术语 Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 10:32:03 "},"content/env/":{"url":"content/env/","title":"平台&环境","keywords":"","body":"Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:21:57 "},"content/frontEnd/":{"url":"content/frontEnd/","title":"前端栈","keywords":"","body":"前端栈 Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:14:22 "},"content/frontEnd/base/html/":{"url":"content/frontEnd/base/html/","title":"html","keywords":"","body":"html Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:16:06 "},"content/frontEnd/base/css/":{"url":"content/frontEnd/base/css/","title":"css","keywords":"","body":"css Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:16:14 "},"content/frontEnd/base/javascript/":{"url":"content/frontEnd/base/javascript/","title":"javascript","keywords":"","body":"javascript Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:17:52 "},"content/frontEnd/tools/":{"url":"content/frontEnd/tools/","title":"工程化","keywords":"","body":"Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:18:18 "},"content/frontEnd/framework/":{"url":"content/frontEnd/framework/","title":"框架","keywords":"","body":"Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:17:59 "},"content/backEnd/":{"url":"content/backEnd/","title":"后端栈","keywords":"","body":"后端栈 Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:12:16 "},"content/backEnd/node/":{"url":"content/backEnd/node/","title":"node.js","keywords":"","body":"node.js Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:30:11 "},"content/backEnd/database/":{"url":"content/backEnd/database/","title":"数据库","keywords":"","body":"数据库 Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:30:26 "},"content/backEnd/graphql/":{"url":"content/backEnd/graphql/","title":"graphql","keywords":"","body":"graphql Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:30:18 "},"content/other/":{"url":"content/other/","title":"其他","keywords":"","body":"Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 12:24:16 "},"content/other/Git.html":{"url":"content/other/Git.html","title":"Git使用","keywords":"","body":"1、Git基础 1.1、版本管理 1.1.1 什么是版本管理 版本管理是一种文件变化的方式，以便将来查阅特定版本的文件内容。 1.1.2 人为维护文档版本的问题 1.文档数量多且命名不清晰导致文档版本混乱 2.每次编辑文档需要复制，不方便 3.多人同时编辑同一个文档，容易产生覆盖 1.2、Git是什么 Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。 1.3、Git安装 Git官网 1.4、 Git基本工作流程 git仓库 暂存区 工作目录 用于存放提交的记录 临时存放被修改的文件 被Git管理的项目目录，也可以说是本地开发项目目录 1.5、 Git的基本使用 1.5.1 Git配置 在使用git前，需要配置git仓库种提交时需要用到的信息： 1.配置提交人姓名：git config --global user.name 提交人姓名 2.配置提交人邮箱：git config --global user.eamil 提交人邮箱 3.查看git配置信息：git config --list 说明：如果要对配置信息进行修改，执行相应的命令，配置只需要配置一次即可 1.5.2 提交步骤 git init // 初始化git仓库 git status // 查看文件状态 git add 文件列表 // 追踪文件 git commit -m 提交信息 // 向仓库中提交代码 git log // 查看提交记录1.5.3 恢复记录 git rest --hard commitID 将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录(commitID版本ID) ![git-rest](D:\\github\\books\\content\\images\\git-rest.jpg) 1.5.4 撤销 用暂存区中的文件覆盖工作目录中的文件：git checkout 文件 将文件从暂存区中删除： git rm --cached 文件 将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：git rest --hard commitID2、Git进阶 2.1 分支 为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本，使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。 2.2 分支命令 git branch 查看分支 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git merge 来源分支 合并分支 git branch -d 分支名称 删除分支（分支被合并后才允许删除）（-D 表示强制删除）2.3 暂时保持更改 在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。使用场景：分支临时切换 存储临时改动：git stash 恢复改动：git stash pop3、Github 在版本控制系统中，大约90%的操作都是在本地仓库中进行：暂存，提交，查看状态或历史记录等，除此之外，如果仅仅以个人在工作，需要设置以给原创仓库来做多人协同开发，GitHub就是以给强大的远程文件管理仓库。3.1 项目推送到远程仓库的命令 git push 远超仓库地址 分支名称 git push 远超仓库地址别名 分支名称 git push -u 远程仓库地址别名 分支名称 （-u记住推送地址及分支，下次推送只需要输入git push即可） git remote add 远程仓库地址别名 远程仓库地址3.2 克隆仓库 克隆源端数据仓库到本地：git clone 仓库地址3.3 拉去远程仓库中最新的版本 git pull 远超仓库地址 分支名称3.4 解决冲突 在多人同时开发的时，如果两个人修改了同以给文件的同一个地方，就会发生冲突，冲突需要人为解决3.5 跨团队协作 首先fork仓库 将仓库克隆在本地进行修改 将仓库推送到远程 发起pull request 仓库的作者审核 仓库的作者合并代码3.6 ssh免登陆 https协议仓库地址：https://github.com/xxx.git 生成密匙：ssh -keygen 密匙存储的目录：c:\\users\\用户.ssh 公钥名称：id_rsa.pub 密钥名称：id_rsa3.7 GIT忽略清单 将不需要被git管理的文件名称添加到此文件中，在执行git命令的适合，git就会忽略这些文件。 git忽略清单文件名称：.gitinore 将工作目录中的文件全部添加到暂存区：git add . Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-25 13:13:21 "},"content/other/console.html":{"url":"content/other/console.html","title":"console详细","keywords":"","body":"console简述 js原生中默认没有console对象，这是宿主对象（也就是浏览器）提供的内置对象，用于访问调试控制台，在不同的浏览器里效果可能不同。 现在大部分的浏览器都是带有调试功能的，而低版本IE没有，所以console对象不存在。 console的方法 1. console.log() / console.debug() / console.info() console.log方法用于在控制台输出信息。它可以接受多个参数，逗号分隔。它会自动在每次输出的结尾，添加换行符。没有返回值回会返回undefined。 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后在进行输出。 console.log方法和console.debug、console.info几乎用户完全一样，唯一不同的表现形式。 IE不支持debug方法 console.log('文字信息'); console.info('提示信息'); console.warn('警告信息'); console.error('错误信息'); 占位符 模式 类型 %s 字符串 %d,%i 整数 %f 浮点数 %o 对象超链接 %c CSS格式化样式 2. console.assert() 接受至少两个参数，第一个参数的值或返回值为false的时候，将会在控制台上抛出一个异常并将其余参数作为异常描述输出。 当第一个参数或返回值为真时，不输出内容 当第一个参数或返回值为假时，输出后面的内容并抛出异常 console.assert(false,123) //抛出错误，并且输出，返回undefined console.assert(true,123) //没有错误，返回undefined console.assert(true, \"你永远看不见我\"); console.assert((function() { return true;})(), \"你永远看不见我\"); console.assert(false, \"你看得见我\"); console.assert((function() { return false;})(), \"你看得见我\"); 3. console.count() 用于计数，输出它被调用了多少次。方法里面可以传入一个字符串作为参数，作为标签对执行次数进行分类 (function() { for (var i = 0; i 4.console.clear() 清空控制台内容 5.console.dir() 用来对一个对象进行检查，并以易于阅读和打印的格式显示 var obj = { name: 'c', age: '20', type: '1' }; console.dir(obj); var arr = [1,2,3] console.dir(arr) var s = 'sdfs' console.dir(s) var n = '123' console.dir(n) 6.console.error(),console.warn() 两个方法用于输出错误和警告信息，一个黄色警告，一个是红色的错误形式. console.error('error红色错误'); console.warn('warn黄色警告'); 7.console.table() 可以将传入的对象或数组这些复合数据以表格形式输出。 var arr= [ { num: \"1\"}, { num: \"2\"}, { num: \"3\" } ]; console.table(arr); var obj= { a:{ num: \"1\"}, b:{ num: \"2\"}, c:{ num: \"3\" } }; console.table(obj); 8.console.time(),console.timeEnd() 这两个方法计算一个操作的执行的时间，console.time()是开始，console.timeEnd()是结束，可以传一个参数，参数为计时器的名称 console.time('计时器1'); for (var i = 0; i 9.console.group(),console.groupCollapsed(),console.groupend() console.group()和console.groupCollapsed()方法用于将显示的信息分组，可以把信息进行折叠和展开，他们都可以传递一个参数，参数默认是分组名，用法都是一样的，唯一区别就是group是默认展开的，groupCollapsed，默认是收起的。 console.group('第一层'); console.group('第二层'); console.log('error'); console.error('error'); console.warn('error'); console.groupEnd(); console.groupEnd(); 10.console.profile(),console.profileEnd() 这两个方法就是比较高级点，用来新建一个性能测试器，可以评估某段代码的性能，可以传一个参数，为生产的性能测试器的名字。 function profile() { for (var i = 0; i 11.console.trace() 该方法用来追踪函数的调用过程，在复杂的架构中可以查找到对应的调用路径。 function d(a) { console.trace(); return a; } function b(a) { return c(a); } function c(a) { return d(a); } var a = b('123'); Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 10:39:08 "},"content/other/cheerio.html":{"url":"content/other/cheerio.html","title":"cheerio抓取网页数据","keywords":"","body":"cheerio 用来解析html的工具库，其语法就像在浏览器中使用jquery一样 安装命令 npm install cheerio cheerio安装完后，就可以使用了。我们看以下代码段是下载任意一个网页的内容，将其放入到curl.js中，并导出 const http = require('http') function download(url,callback){ http.get(url,function(res){ var data = '' res.on('data',function(chunk){ data+=chunk }) res.on('end',function(){ callback(data) }) }).on('error',function(){ callback(null) }) } exports.download = download 然后使用cheerio解析HTML，找到想要的数据 我们来分析一下页面，要抓取http://v.163.com/special/opencourse/englishs1.html 这个页面中的视频，视频的地址都在下载的按钮里。其中一个下载按钮的html的代码如下: 我们取到其中的href属性，只需要进行如下选择即可 $('a.downbtn').attr('href') 可以在index.js中写入代码： var cheerio = require('cheerio') var server = require('./curl') var url = \"http://v.163.com/special/opencourse/englishs1.html\" server.download(url,function(data){ if(data){ var $ = cheerio.load(data) $('a.downbtn').each(function(i,e){ console.log($(e).attr('href')) }) console.log('done') }else{ console.log('error') } }) 然后执行:node index.js cheero API 将用到的标记示例 Apple Orange Pear 我们将会在所有的API例子中用到的HTML标记 Loading 首先需要加载HTML，这一步对jQuery来说是必须的，通过cheerio，我们需要把HTML document传进去。 这是首选： var cheerio = require('cheerio'); var $ = cheerio.load('...') 或者通过传递字符串作为内容来加载HTML $=require('cheerio') $('ul','...') 或这样： $ =require('cheerio'); $('li','ul','...'); 也可以传递一个额外的对象给.load()，如果需要更改任何的默认解析选项的话 $ = cheerio.load('...',{ ignoreWhitespace:true, xmlMode:true}); 这些解析选项都是直接来自httpparser,因此任何在htmlparser里有效的选项在chreeio里也是行得通的，默认的选项如下： { ignoreWhitespace:false, xmlMode:false, lowerCaseTags:false } Selectors cheerio的选择器几乎和jquery 一样 $(selectior,[context],[root]) 选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。 $('.apple','#fruits').text() //=> Apple $('ul .pear').attr('class') //=> pear $('li[class=orange]').html() //=> Orange Attributes 获得和修改属性 .attr(name,value) 获得和修改属性。在匹配的元素中只能获得第一元素的属性。如果设置一个属性的值为null，则移除这个属性。你也可以传递一对键值，或者一个函数。 $('ul').attr('id') //=> fruits $('.apple').attr('id','favorite').html() //=> Apple .val([value]) 获得和修改input,select,textarea的value.注意: 对于传递键值和函数的支持还没有被加进去。 $('input[type=\"text\"]').val() //=> input_text $('input[type=\"text\"]').val('test').html() //=> .removeAttr(name) 通过name删除属性 $('.pear').removeAttr('class').html() //=> Pear .hasClass( className ) 检查匹配的元素是否有给出的类名 $('.pear').hasClass('pear') //=> true $('apple').hasClass('fruit') //=> false $('li').hasClass('pear') //=> true .addClass(className) 增加class(es)给所有匹配的elements.也可以传函数。 $('.pear').addClass('fruit').html() //=> Pear $('.apple').addClass('fruit red').html() //=> Apple .removeClass([className]) 从选择的elements里去除一个或多个有空格分开的class。如果className 没有定义，所有的classes将会被去除，也可以传函数。 $('.pear').removeClass('pear').html() //=> Pear $('.apple').addClass('red').removeClass().html() //=> Apple .toggleClass( className, [switch] ) 添加或删除class，依赖于当前是否有该class. $('.apple.green').toggleClass('fruit green red').html() //=> Apple $('.apple.green').toggleClass('fruit green red', true).html() //=> Apple .is( selector )、.is( element )、.is( selection )、.is( function(index) ) 有任何元素匹配selector就返回true。如果使用判定函数，判定函数在选中的元素中执行，所以this指向当前的元素。 .find(selector) 获得一个在匹配的元素中由选择器滤过的后代。 $('#fruits').find('li').length //=> 3 .parent([selector]) 获得每个匹配元素的parent,可选择性的通过selector筛选。 $('.pear').parent().attr('id') //=> fruits .parents([selector]) 获得通过选择器筛选匹配的元素的parent集合。 $('.orange').parents().length // => 2 $('.orange').parents('#fruits').length // => 1 .closest([selector]) 对于每个集合内的元素，通过测试这个元素和DOM层级关系上的祖先元素，获得第一个匹配的元素 $('.orange').closest()// => [] $('.orange').closest('.apple')// => [] $('.orange').closest('li')// => [Orange] $('.orange').closest('#fruits')// => [ ... ] .next() 获得第一个本元素之后的同级元素 $('.apple').next().hasClass('orange') //=> true .nextAll() 获得本元素之后的所有同级元素 $('.apple').nextAll() //=> [Orange, Pear] .prev() 获得本元素之前的第一个同级元素 $('.orange').prev().hasClass('apple') //=> true .preAll() 获得本元素前的所有同级元素 $('.pear').prevAll() //=> [Orange, Apple] .slice(start,[end]) 获得选定范围内的元素 $('li').slice(1).eq(0).text() //=> 'Orange' $('li').slice(1,2).length //=> 1 .siblings(selector) 获得被选择的同级元素，不包括本身 $('.pear').siblings().length //=> 2 $('.pear').siblings('.orange').length //=> 1 .children(selector) 获被选择元素的子元素 $('#fruits').children().length //=> 3 $('#fruits').children('.pear').text() //=> Pear .each(function(index,element)) 迭代一个cheerio对象，为每个匹配元素执行一个函数。When the callback is fired, the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element.要提早跳出循环，返回false. var fruits =[]; $('li').each(function(i, elem){ fruits[i]= $(this).text();}); fruits.join(', '); //=> Apple, Orange, Pear .map(function(index,element)) 迭代一个cheerio对象，为每个匹配元素执行一个函数。Map会返回一个迭代结果的数组。the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element $('li').map(function(i, el){ // this === el return $(this).attr('class'); }).join(', '); //=> apple, orange, pear .filter(selector)、.filter(function(index)) 迭代一个cheerio对象，滤出匹配选择器或者是传进去的函数的元素。如果使用函数方法，这个函数在被选择的元素中执行，所以this指向的手势当前元素。 //Selector: $('li').filter('.orange').attr('class'); //=> orange //Function: $('li').filter(function(i, el){ // this === el return $(this).attr('class')==='orange'; }).attr('class') //=> orange .first() 会选择chreeio对象的第一个元素 $('#fruits').children().first().text() //=> Apple .last() 会选择chreeio对象的最后一个元素 $('#fruits').children().last().text() //=> Pear .eq(i) 通过索引筛选匹配的元素。使用.eq(-i)就从最后一个元素向前数。 $('li').eq(0).text() //=> Apple $('li').eq(-1).text() //=> Pear Manipulation 改变DOM结构的方法 .append(content,[content...]) 在每个元素最后插入一个子元素 $('ul').append('Plum') $.html() //=> // Apple // Orange // Pear // Plum // .prepend(content,[content,...]) 在每个元素最前插入一个子元素 $('ul').prepend('Plum') $.html() //=> // Plum // Apple // Orange // Pear // .after(content,[content,...]) 在每个匹配元素之后插入一个元素 $('.apple').after('Plum') $.html() //=> // Apple // Plum // Orange // Pear // .before(content,[content,...]) 在每个匹配的元素之前插入一个元素 $('.apple').before('Plum') $.html() //=> // Plum // Apple // Orange // Pear // .remove( [selector] ) 从DOM中去除匹配的元素和它们的子元素。选择器用来筛选要删除的元素。 $('.pear').remove() $.html() //=> // Apple // Orange // .replaceWith( content ) 替换匹配的的元素 var plum = $('Plum') $('.pear').replaceWith(plum) $.html() //=> // Apple // Orange // Plum // .empty() 清空一个元素，移除所有的子元素 $('ul').empty() $.html() //=> .html( [htmlString] ) 获得元素的HTML字符串。如果htmlString有内容的话，将会替代原来的HTML $('.orange').html() //=> Orange $('#fruits').html('Mango').html() //=> Mango .text( [textString] ) 获得元素的text内容，包括子元素。如果textString被指定的话，每个元素的text内容都会被替换。 $('.orange').text() //=> Orange $('ul').text() //=> Apple // Orange // Pear Rendering 如果你想呈送document，你能使用html多效用函数。 $.html() //=> // Apple // Orange // Pear // 如果你想呈送outerHTML,你可以使用 $.html(selector) $.html('.pear') //=> Pear //By default, html will leave some tags open. Sometimes you may instead want to render a //valid XML document. For example, you might parse the following XML snippet: $ = cheerio.load(''); //... and later want to render to XML. To do this, you can use the 'xml' utility function: $.xml()//=> Miscellaneous 不属于其它地方的DOM 元素方法 .toArray() 取得所有的在DOM元素，转化为数组、 $('li').toArray() //=> [ {...}, {...}, {...} ] .clone() 克隆cheerio对象 var moreFruit = $('#fruits').clone() Utilities $.root Sometimes you need to work with the top-level root element. To query it, you can use $.root(). $.root().append('').html(); //=> ... $.contains( container, contained ) 查看cotained元素是否是container元素的子元素 $.parseHTML( data [, context ] [, keepScripts ] ) 将字符串解析为DOM节点数组。context参数对chreeio没有意义，但是用来维护APi的兼容性。 Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-04-05 10:39:08 "},"content/other/yarn.html":{"url":"content/other/yarn.html","title":"npm和yarn依赖包管理的原理，两者的区别","keywords":"","body":"一、 包管理工具：npm、cnpm、yarn、pnpm 首先他们都是依赖包的管理工具，都可以通过命令来安装包或模块； 1、NPM npm是集成在node.js安装包，在安装node.js就同时安装好了，这也就是node.js能够如此成功的主要原因，npm是围绕着语义版本控制的思想而设计的。給定一个版本号：主版本号.次版本号.补丁版本号。 主版本号：当API发生改变，并于之前的版本不兼容的时候 次版本号：当增加了功能，但是向后兼容的时候 补丁版本号：当做了向后兼容的缺陷修复的时候 其常见的使用场景由： 允许用户从npm服务器下载别人编写的第三方包到本地使用 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用 npm仍存在一定的缺点： 安装速度慢，特别是npm install需要等较长的时间，还不一定安装成功 同一个项目，安装的时候无法保持一致性， 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出错误，npm会继续下载和安装包，所抛出的错误日志就会在一大堆的警告中丢失，甚至不会注意到实际发生的错误。2、cnpm cnpm跟npm用法完全一致，只是在执行命令的时候npm改为cnpm npm安装插件是从国外服务器下载，受网络影响，可能出现异常，于是淘宝团队对npm做了一个完整的镜像，同步频率为10分钟一次，尽量保证于官方服务同步 官方地址：http://npm.taobao.org 安装注册：npm install -g cnpm --registry=https://registry.npm.taobao.org 3、yarn 快速、可靠、安全的依赖管理工具 yarn是由facebook,google等联合推出的一个新的JS包管理工具，是为了弥补npm的一些缺陷而出现的。一开始的主要目标是解决npm安装过程中由于语义版本控制而导致不确定性的问题，虽然npm 可以使用shrinkwrap来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发任意知道并启用这个选项。 yarn采用了不同的做法，每个yarn安装都会生成一个yarn.lock文件，该文件包含要安装的内容和校验和，以确保使用的库的版本相同 yarn优点 速度快 并行安装：无论npm还是yarn在执行包的安装时，都会执行一系列任务，npm是按照队列执行每个package,也就是说必须要等到当前package安装完成之后，才能继续后面的安装。而yarn是同步执行所有任务，提高了性能。 离线模式：如果之前已经安装过一个软件包，用yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载 安装版本统一：为防止拉取不同版本，yarn有一个锁定文件记录了被确定安装上的模块的版本号，每次只要新增了一个模块，yarn就会创建或更新yarn.lock文件，只要保证了每次拉取同一个项目依赖时，使用的都是一样的模块版本 更简洁的输出：npm的输出信息比较冗长，命令行里会不断打印出所有被安装上的依赖，相比之下，yarn简介输出，默认情况下，结合了emoij直观的打印出必要的信息 多注册来源处理：所有的依赖包，不管被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是npm要么是bower，防止出现混乱不一致。 更好的语义化：yarn改变了一些npm命令的名称，比如yarn add/remove 感觉上比npm install/uninstall更清晰 4、pnpm(Fast, disk space efficient package manager) 快速、高效的磁盘空间包管理器， pnpm允许起来非常的块，超过了npm和yarn pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件，这是yarn的最大性能弱点之一 使用链接并不容易，会带来一对问题需要考虑 pnpm继承了yarn的所有优点，包括离线模式和确定性安装 总结 npm仍然提供了一个非常有用的解决方案，支持大量的测试用例，大多书开发任意使用原始的npm客户端仍然可以做的很好yarn的确定性安装，可以避免很多潜在的问题，相对安全pnpm可能是一些测试用例的更好选择，比如可以在运行大量继承测试并希望尽可能的安装依赖关系的中小型团队中发挥作用 yarn和npm命令对比 npm yarn npm install yarn npm install react --save yarn add react npm uninstall react --save yarn remove react npm install react --save-dev yarn add react --dev npm update --save yarn upgrade Copyright © cdliudefu 2019 all right reserved，powered by GitbookFile Modify: 2020-07-01 17:19:44 "}}